# -*- coding: utf-8 -*-
"""SoundML.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qH8cQfFL1X61-I0TAXO1zy8knAr_hw_X
"""
""" Please read!!!!!!!
# the code have to run on google colab online engine
# Make sure you copy and paste the code to google colab online engine
# This is the first part of the code (first cell)
"""
# importing the libraries
from pandas.core.api import DateOffset
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
import time
# load google sheet api
from google.colab import drive
# dataset file path
drive.mount("/content/drive")

# importing the dataset (file is stored as google sheet format)
from google.colab import auth
auth.authenticate_user()

import gspread
from google.auth import default
creds, _ = default()

gc = gspread.authorize(creds)

# open the file named as sound from the google drive
dataset = gc.open('sound').sheet1
data = dataset.get_all_values()
headers = data.pop(0)
dataset = pd.DataFrame(data, columns = headers)
n = len(dataset)
print(dataset.shape)
#dataset.info()
# format date type as int
dataset["time"] = pd.to_datetime(dataset['time'])
dataset["elapsed"] = dataset["elapsed"].astype(np.uint8)
dataset["sound"] = dataset["sound"].astype(np.uint8)

X = dataset.iloc[:, 1].values
y = dataset.iloc[:, 2].values

# print(X)
# print(y)

X = X.reshape(-1, 1)
y = y.reshape(-1, 1)

# get training and testing sets
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)

lin_reg = LinearRegression()
lin_reg.fit(X_train, y_train)

#print("Model R2:", lin_reg.score(X_test, y_test))

# Poly Regression
poly_reg = PolynomialFeatures(degree=4)
X_poly = poly_reg.fit_transform(X_train)

# apply overfitting to test set
X_poly_test = poly_reg.transform(X_test)

lin_reg_poly = LinearRegression()
lin_reg_poly.fit(X_poly, y_train)



# Visualising the polynomial regression model results
X_grid = np.arange(min(X), max(X), 0.1)
X_grid = X_grid.reshape((len(X_grid), 1))
plt.scatter(X, y, color='red')
plt.plot(X, lin_reg_poly.predict(poly_reg.fit_transform(X)), color='blue')
plt.title('Sound Visualization (Polynomial Regression)')
plt.xlabel('Time')
plt.ylabel('Sound')
plt.show()

y_pred = lin_reg_poly.predict(X_poly_test)

# get confidence_interval, confidence=0.95
from scipy import stats

confidence_interval = stats.t.interval(0.95, len(y_pred) - 1, loc=np.mean(y_pred), scale=stats.sem(y_pred))
print(confidence_interval)

# pick thretshold value from confidence_interval
lower_threshold = confidence_interval[0][0] * 1.5 # 1.5 is a factor to make the threshold more strict
upper_threshold = confidence_interval[1][0] * 0.5 # define a function to check is new data in a reasonable level
print(lower_threshold, upper_threshold)

# a random dataset for testing
new_data_X = np.random.normal(5, 3, size=20)

# define a function to check is new data in a reasonable level
def within_error_margin(new_data_X):
    global X

    new_data_X = new_data_X.reshape(-1, 1)
    new_data_X_poly = poly_reg.transform(new_data_X)

    preds = lin_reg_poly.predict(new_data_X_poly).flatten()
    print(preds)
    errors = np.where((lower_threshold < preds) & (preds < upper_threshold), 0, 1)  # 0 = no error, 1 = error

    if any(errors == 1):
        print("[ERROR]: Data appears to be outside of bounds.")
        return X

    X = np.concatenate((X, new_data_X))
    return X


within_error_margin(new_data_X);
"""########################## End of the first part of code ####################################"""

"""########################## Start of the second part of code ####################################"""
"""
Please Read !!!
# This is the second part of the code (second cell)
# Creat a new cell, and copy and paste the code to a new cell
# rerun the data collection program to collect new set of data in the same colomn
# program will check and compare the new set of data with previos 
# run the function as a loop
"""
from IPython.display import clear_output
while True:
  #run loop for every 10 seconds
  time.sleep(5)
  dataset = gc.open('sound').sheet1
  data = dataset.get_all_values()
  headers = data.pop(0)
  dataset = pd.DataFrame(data, columns = headers)
  dataset["time"] = pd.to_datetime(dataset['time'])
  dataset["elapsed"] = dataset["elapsed"].astype(np.uint8)
  dataset["sound"] = dataset["sound"].astype(np.uint8)
  dataset_new = dataset
  n_new = len(dataset)

  if n != n_new:
    within_error_margin(dataset_new["sound"].iloc[n: n_new].values)
  else:
    print("No change.")

# count the number of times the sound is above the threshold and print the result
    count = 0
    for i in range(n, n_new):
        if dataset_new["sound"].iloc[i] > upper_threshold:
            count += 1
    print("Number of times the sound is above the threshold:", count)
        if count > 5:
            print("The sound is above the threshold for more than 5 times.")
            print("Please stop the CNC!")
            break


# loop to update the graph when new data has been recorded
  if n != n_new:
   X = dataset_new.iloc[n: n_new, 1].values
   y = dataset_new.iloc[n: n_new, 2].values

   X = X.reshape(-1, 1)
   y = y.reshape(-1, 1)
   
   X_grid = np.arange(min(X), max(X), 0.1)
   X_grid = X_grid.reshape((len(X_grid), 1))
   plt.scatter(X, y, color='red')
   plt.plot(X, lin_reg_poly.predict(poly_reg.transform(X)), color='blue')
   plt.title('Truth or bluff(Polynomial Regression)')
   plt.xlabel('Time')
   plt.ylabel('Sound')
   plt.show()

  clear_output(wait = True)